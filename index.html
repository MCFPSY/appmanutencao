/**
 * CLOUDFLARE WORKER - CHATBOT GEMINI AI
 * VersÃ£o: v3.8.2.18
 * Data: 2026-01-20
 * Backend para anÃ¡lise de pedidos de manutenÃ§Ã£o MCF+PSY
 * 
 * CONFIGURAÃ‡ÃƒO v3.8.2.18:
 * âœ… Modelo: gemini-2.5-flash (mais recente e estÃ¡vel)
 * âœ… API: v1beta (funcional)
 * âœ… Event handler: ES6 modules
 * âœ… Logs detalhados para debug
 * âœ… ValidaÃ§Ã£o robusta da API key
 * âœ… Tratamento de erros melhorado
 * âœ… CORS habilitado
 * âœ… maxOutputTokens: 4096 (respostas completas sem truncar)
 * âœ… temperature: 0.0 (100% DETERMINÃSTICO - mesma resposta SEMPRE!)
 * âœ… topK: 1 (sempre escolhe palavra mais provÃ¡vel)
 * âœ… topP: 1.0 (sem amostragem nucleus)
 * âœ… Suporte a imagens/tabelas de manuais (URLs no formato ðŸ“Š [TABLE X])
 * âœ… ðŸ†• BUSCA VETORIAL com OpenAI embeddings + Supabase pgvector
 * âœ… ðŸ†• Busca semÃ¢ntica (entende sinÃ´nimos e contexto)
 * 
 * CHANGELOG v3.8.2.18 (2026-01-20):
 * - ðŸŽ¯ FIX ULTRA-CRÃTICO: Temperature ZERADA (0.0) + topK=1 + topP=1.0
 * - ðŸŽ¯ PROBLEMA: Mesmo com temp=0.2 ainda havia variaÃ§Ã£o nas respostas
 * - ðŸŽ¯ CAUSA: topK=40 e topP=0.95 permitem aleatoriedade na escolha de palavras
 * - ðŸŽ¯ SOLUÃ‡ÃƒO: temp=0.0 + topK=1 = ZERO aleatoriedade (100% determinÃ­stico)
 * - âœ… Resultado: SEMPRE a mesma resposta palavra por palavra
 * 
 * CHANGELOG v3.8.2.17 (2026-01-20):
 * - ðŸŽ¯ FIX CRÃTICO: Temperature baixada de 0.7 para 0.2
 * - ðŸŽ¯ PROBLEMA: IA dava respostas diferentes para a mesma pergunta
 * - ðŸŽ¯ CAUSA: Temperature alta = aleatoriedade/criatividade
 * - ðŸŽ¯ SOLUÃ‡ÃƒO: Temperature baixa = respostas consistentes e tÃ©cnicas
 * - âœ… Resultado: Sempre a mesma resposta (determinÃ­stico)
 * 
 * CHANGELOG v3.8.2.11 (2026-01-20):
 * - ðŸ› FIX CRÃTICO: Adicionado try-catch em JSON.stringify para capturar erros
 * - ðŸ› FIX: Tratamento adequado de contextos com referÃªncias circulares
 * - âœ… Mensagens de erro mais claras quando JSON.stringify falha
 * 
 * CHANGELOG v3.7.6.10 (2026-01-15):
 * - ðŸ†• Adicionada busca vetorial (embeddings + pgvector)
 * - ðŸ†• IntegraÃ§Ã£o com OpenAI para gerar embeddings
 * - ðŸ†• IntegraÃ§Ã£o com Supabase para busca semÃ¢ntica
 * - ðŸ†• Contexto enriquecido com seÃ§Ãµes mais relevantes
 * - âœ… Respostas mais precisas e focadas
 * 
 * VARIÃVEIS DE AMBIENTE NECESSÃRIAS:
 * - GEMINI_API_KEY: Chave da API Gemini
 * - OPENAI_API_KEY: Chave da API OpenAI (para embeddings)
 * - SUPABASE_ANON_KEY: Chave anÃ´nima do Supabase (para busca vetorial)
 */

// ============================================
// CONFIGURAÃ‡ÃƒO
// ============================================

const GEMINI_MODEL = 'gemini-2.5-flash';
const GEMINI_API_BASE = 'https://generativelanguage.googleapis.com/v1beta';

// ðŸ†• v3.7.6.10: ConfiguraÃ§Ã£o OpenAI para embeddings
const OPENAI_EMBEDDINGS_MODEL = 'text-embedding-3-small';
const OPENAI_API_BASE = 'https://api.openai.com/v1';

// ðŸ†• v3.7.6.10: ConfiguraÃ§Ã£o Supabase para busca vetorial
const SUPABASE_URL = 'https://wegftalccimrnnlmoiyn.supabase.co'; // âœ… URL configurado
const USE_VECTOR_SEARCH = false; // âš ï¸ Busca vetorial DESATIVADA (funÃ§Ã£o match_manuais nÃ£o existe no Supabase)

// CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

// ============================================
// HANDLER PRINCIPAL (ES6 MODULES)
// ============================================

export default {
  async fetch(request, env, ctx) {
    console.log('ðŸ”¥ Nova requisiÃ§Ã£o:', request.method, request.url);

    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    // Aceita apenas POST
    if (request.method !== 'POST') {
      return new Response(JSON.stringify({ erro: 'MÃ©todo nÃ£o permitido. Use POST.' }), {
        status: 405,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    try {
      console.log('ðŸ”µ [DEBUG] InÃ­cio do try block');
      
      // âœ… Verificar API key (env Ã© passado corretamente no ES6 modules)
      console.log('ðŸ”µ [DEBUG] Verificando API key...');
      const apiKey = env.GEMINI_API_KEY;
      
      if (!apiKey) {
        console.error('âŒ GEMINI_API_KEY nÃ£o encontrada no ambiente!');
        return new Response(JSON.stringify({ 
          erro: 'ConfiguraÃ§Ã£o invÃ¡lida', 
          detalhes: 'API key nÃ£o configurada. Configure GEMINI_API_KEY nas variÃ¡veis de ambiente do Worker.',
          timestamp: new Date().toISOString()
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      console.log('âœ… API key encontrada:', apiKey.substring(0, 10) + '...');

      // Parse do body
      console.log('ðŸ”µ [DEBUG] Fazendo parse do body...');
      const body = await request.json();
      console.log('ðŸ”µ [DEBUG] Body parseado, extraindo pergunta e contexto...');
      const { pergunta, contexto } = body;

      console.log('ðŸ”µ [DEBUG] Pergunta recebida:', pergunta);
      console.log('ðŸ”µ [DEBUG] Contexto type:', typeof contexto);
      console.log('ðŸ”µ [DEBUG] Contexto keys:', Object.keys(contexto || {}));
      console.log('ðŸ“Š Contexto:', JSON.stringify(contexto).substring(0, 200) + '...');
      
      // ðŸ†• v3.7.6.9: Debug - Verificar se hÃ¡ URLs de imagens no contexto
      console.log('ðŸ”µ [DEBUG] Criando contextoStr...');
      let contextoStr;
      try {
        contextoStr = JSON.stringify(contexto);
        console.log('ðŸ”µ [DEBUG] contextoStr criado, length:', contextoStr.length);
      } catch (jsonError) {
        console.error('âŒ ERRO ao fazer JSON.stringify do contexto:', jsonError.message);
        return new Response(JSON.stringify({ 
          erro: 'Erro ao processar contexto', 
          detalhes: `Falha ao serializar contexto: ${jsonError.message}. O contexto pode conter referÃªncias circulares ou dados problemÃ¡ticos.`,
          timestamp: new Date().toISOString()
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
      
      console.log('ðŸ”µ [DEBUG] Procurando URLs no contexto...');
      const urlsEncontradas = contextoStr.match(/ðŸ“Š \[TABLE \d+\]: https?:\/\/[^\s\n]+/g) || [];
      console.log('ðŸ”µ [DEBUG] URLs encontradas:', urlsEncontradas.length);
      
      if (urlsEncontradas.length > 0) {
        console.log('ðŸ–¼ï¸ URLs de imagens encontradas no contexto:', urlsEncontradas.length);
        urlsEncontradas.forEach((url, idx) => console.log(`   ${idx + 1}. ${url}`));
      } else {
        console.log('âš ï¸ Nenhuma URL de imagem encontrada no contexto');
      }

      if (!pergunta || !contexto) {
        return new Response(JSON.stringify({ 
          erro: 'Dados invÃ¡lidos', 
          detalhes: 'Envie "pergunta" e "contexto" no corpo da requisiÃ§Ã£o.' 
        }), {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      console.log('ðŸ”µ [DEBUG] Iniciando preparaÃ§Ã£o de contexto...');
      
      // ðŸ†• v3.7.6.10: Busca vetorial (se ativada e se houver manuais na pergunta)
      let contextoEnriquecido = contexto;
      
      console.log('ðŸ”µ [DEBUG] USE_VECTOR_SEARCH:', USE_VECTOR_SEARCH);
      console.log('ðŸ”µ [DEBUG] OPENAI_API_KEY exists:', !!env.OPENAI_API_KEY);
      console.log('ðŸ”µ [DEBUG] SUPABASE_ANON_KEY exists:', !!env.SUPABASE_ANON_KEY);
      
      if (USE_VECTOR_SEARCH && env.OPENAI_API_KEY && env.SUPABASE_ANON_KEY) {
        try {
          // Detectar se a pergunta menciona manuais/equipamentos
          const mencionaManual = /manual|lubrific|manutenÃ§Ã£o|tabela|capÃ­tulo|equipamento/i.test(pergunta);
          
          if (mencionaManual) {
            console.log('ðŸ§  [VECTOR] Pergunta menciona manuais, usando busca vetorial...');
            
            const resultadosVetoriais = await buscarConteudoVetorial(
              pergunta,
              env.OPENAI_API_KEY,
              env.SUPABASE_ANON_KEY
            );
            
            if (resultadosVetoriais.length > 0) {
              // Adicionar resultados vetoriais ao contexto
              contextoEnriquecido = {
                ...contexto,
                manuais_vetoriais: {
                  disponivel: true,
                  resultados: resultadosVetoriais.map(r => ({
                    secao: r.secao,
                    conteudo: r.conteudo,
                    paginas: `${r.pagina_inicio}-${r.pagina_fim}`,
                    similaridade: r.similarity
                  }))
                }
              };
              
              console.log(`âœ… [VECTOR] ${resultadosVetoriais.length} seÃ§Ãµes adicionadas ao contexto`);
            }
          } else {
            console.log('â„¹ï¸ [VECTOR] Pergunta nÃ£o menciona manuais, pulando busca vetorial');
          }
        } catch (error) {
          console.error('âš ï¸ [VECTOR] Erro na busca vetorial (continuando sem):', error);
          // Continuar sem busca vetorial
        }
      } else {
        console.log('â„¹ï¸ [VECTOR] Busca vetorial desativada ou chaves nÃ£o configuradas');
      }
      
      console.log('ðŸ”µ [DEBUG] Preparando contexto enriquecido como string...');
      // ðŸ†• v3.7.6.10: Preparar contexto como string (para busca de URLs)
      let contextoEnriquecidoStr;
      try {
        contextoEnriquecidoStr = JSON.stringify(contextoEnriquecido);
        console.log('ðŸ”µ [DEBUG] contextoEnriquecidoStr length:', contextoEnriquecidoStr.length);
      } catch (jsonError) {
        console.error('âŒ ERRO ao fazer JSON.stringify do contextoEnriquecido:', jsonError.message);
        return new Response(JSON.stringify({ 
          erro: 'Erro ao processar contexto enriquecido', 
          detalhes: `Falha ao serializar contexto: ${jsonError.message}`,
          timestamp: new Date().toISOString()
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
      
      console.log('ðŸ”µ [DEBUG] Chamando Gemini...');
      // Chamar Gemini com contexto (enriquecido ou original)
      const resultado = await chamarGemini(pergunta, contextoEnriquecido, apiKey, contextoEnriquecidoStr);
      console.log('ðŸ”µ [DEBUG] Gemini retornou resultado');

      return new Response(JSON.stringify({ 
        resposta: resultado.resposta,
        debug_logs: resultado.debug_logs, // ðŸ†• v3.7.6.10: Incluir logs de debug na resposta
        timestamp: new Date().toISOString()
      }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });

    } catch (error) {
      console.error('âŒ Erro no Worker:', error);
      console.error('âŒ Error name:', error.name);
      console.error('âŒ Error message:', error.message);
      console.error('âŒ Error stack:', error.stack);
      
      return new Response(JSON.stringify({ 
        erro: 'Erro ao processar a requisiÃ§Ã£o.',
        detalhes: error.message,
        stack: error.stack,
        nome: error.name,
        timestamp: new Date().toISOString()
      }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  }
};

// ============================================
// ðŸ†• v3.7.6.10: FUNÃ‡Ã•ES DE BUSCA VETORIAL
// ============================================

/**
 * Gerar embedding usando OpenAI API
 */
async function gerarEmbedding(texto, apiKey) {
  const textoLimitado = texto.substring(0, 30000);
  
  const response = await fetch(`${OPENAI_API_BASE}/embeddings`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      input: textoLimitado,
      model: OPENAI_EMBEDDINGS_MODEL
    })
  });
  
  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(`OpenAI API error: ${response.status} - ${errorData.error?.message}`);
  }
  
  const data = await response.json();
  return data.data[0].embedding;
}

/**
 * Buscar conteÃºdo similar usando busca vetorial (Supabase + pgvector)
 */
async function buscarConteudoVetorial(pergunta, openaiKey, supabaseKey) {
  console.log('ðŸ” [VECTOR] Iniciando busca vetorial...');
  
  // 1. Gerar embedding da pergunta
  const embedding = await gerarEmbedding(pergunta, openaiKey);
  console.log('âœ… [VECTOR] Embedding da pergunta gerado');
  
  // 2. Buscar no Supabase usando RPC
  const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/match_manuais`, {
    method: 'POST',
    headers: {
      'apikey': supabaseKey,
      'Authorization': `Bearer ${supabaseKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      query_embedding: embedding,
      match_threshold: 0.7,
      match_count: 3
    })
  });
  
  if (!response.ok) {
    const errorData = await response.text();
    console.error('âŒ [VECTOR] Erro do Supabase:', errorData);
    throw new Error(`Supabase error: ${response.status}`);
  }
  
  const resultados = await response.json();
  console.log(`âœ… [VECTOR] ${resultados.length} resultados encontrados`);
  
  return resultados;
}

// ============================================
// FUNÃ‡ÃƒO PARA CHAMAR GEMINI AI
// ============================================

async function chamarGemini(pergunta, contexto, apiKey, contextoStr = null) {
  console.log('ðŸ”µ [DEBUG-GEMINI] FunÃ§Ã£o chamarGemini iniciada');
  console.log('ðŸ”µ [DEBUG-GEMINI] pergunta:', pergunta?.substring(0, 50));
  console.log('ðŸ”µ [DEBUG-GEMINI] contexto type:', typeof contexto);
  console.log('ðŸ”µ [DEBUG-GEMINI] apiKey exists:', !!apiKey);
  console.log('ðŸ”µ [DEBUG-GEMINI] contextoStr:', contextoStr ? 'fornecido' : 'null');
  
  console.log('ðŸ¤– Chamando Gemini AI...');
  
  // ðŸ†• v3.7.6.10: Array para armazenar logs de debug
  const debugLogs = [];
  debugLogs.push('ðŸ¤– Iniciando chamada ao Gemini AI...');

  console.log('ðŸ”µ [DEBUG-GEMINI] Preparando contextoStr...');
  // Preparar contexto como string se nÃ£o for fornecido
  if (!contextoStr) {
    console.log('ðŸ”µ [DEBUG-GEMINI] contextoStr Ã© null, criando...');
    contextoStr = JSON.stringify(contexto, null, 2);
  }
  console.log('ðŸ”µ [DEBUG-GEMINI] contextoStr length:', contextoStr.length);

  // Preparar prompt em PortuguÃªs
  const prompt = `Ã‰s um assistente inteligente especializado em anÃ¡lise de manutenÃ§Ã£o industrial para as empresas MCF e PSY.

**DADOS DO SISTEMA:**
${contextoStr}

**PERGUNTA DO UTILIZADOR:**
${pergunta}

**INSTRUÃ‡Ã•ES:**
1. Analisa os dados fornecidos
2. Responde de forma clara e objetiva em **PortuguÃªs de Portugal**
3. Usa bullets (â€¢) para listas
4. Destaca nÃºmeros importantes com **negrito**
5. Se possÃ­vel, sugere aÃ§Ãµes ou insights relevantes
6. MantÃ©m o tom profissional mas acessÃ­vel

**âš ï¸ REGRA OBRIGATÃ“RIA PARA IMAGENS/TABELAS:**

Se encontrares URLs no formato:
ðŸ“Š [TABLE 1]: https://wegftalccimrnnlmoiyn.supabase.co/storage/...
ðŸ“Š [TABLE 2]: https://wegftalccimrnnlmoiyn.supabase.co/storage/...
ðŸ–¼ï¸ [DIAGRAM 1]: https://wegftalccimrnnlmoiyn.supabase.co/storage/...

**INSERÃ‡ÃƒO INLINE OBRIGATÃ“RIA:**
1. **Quando mencionares "Tabela 6", INSERE a URL LOGO A SEGUIR Ã  menÃ§Ã£o!**
2. **NÃ£o agrupes todas as URLs no final da resposta!**
3. **Cada menÃ§Ã£o de tabela/figura deve ter a URL correspondente imediatamente apÃ³s!**

âœ… CORRETO (INLINE):
"Como mostrado na Tabela 6 abaixo:

ðŸ“Š [TABLE 1]: https://wegftalccimrnnlmoiyn.supabase.co/storage/v1/object/public/manuais/abc123/page_003_table_00.png

A tabela mostra... continuaÃ§Ã£o do texto...

Veja tambÃ©m a Tabela 7:

ðŸ“Š [TABLE 2]: https://wegftalccimrnnlmoiyn.supabase.co/storage/v1/object/public/manuais/abc123/page_003_table_01.png

Esta segunda tabela indica..."

âŒ ERRADO (URLs agrupadas no final):
"Veja as Tabelas 6 e 7 no manual.

[... todo o texto ...]

ðŸ“Š [TABLE 1]: https://...
ðŸ“Š [TABLE 2]: https://..."

âŒ ERRADO (caractere estranho):
"Aqui estÃ¡ a Tabela 6:
ï¿½ [imagem]
A tabela mostra..."

**RESPOSTA:**`;

  try {
    console.log('ðŸ”µ [DEBUG-GEMINI] Entrando no try block...');
    
    // âœ… v1beta + gemini-2.5-flash
    console.log('ðŸ”µ [DEBUG-GEMINI] Construindo URL da API...');
    const url = `${GEMINI_API_BASE}/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;
    
    console.log('ðŸŒ URL da API:', url.replace(apiKey, 'API_KEY_HIDDEN'));
    console.log('ðŸ” Modelo usado:', GEMINI_MODEL);

    console.log('ðŸ”µ [DEBUG-GEMINI] Fazendo fetch para Gemini API...');
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.0,  // ðŸŽ¯ v3.8.2.18: BAIXADO para 0.0 - 100% DETERMINÃSTICO!
          topK: 1,           // ðŸŽ¯ v3.8.2.18: topK=1 - Sempre escolhe palavra mais provÃ¡vel
          topP: 1.0,         // ðŸŽ¯ v3.8.2.18: topP=1.0 - Sem amostragem nucleus
          maxOutputTokens: 4096, // âœ… Aumentado de 1024 para 4096 para respostas mais completas
        }
      })
    });

    console.log('ðŸ“¡ Status da resposta:', response.status, response.statusText);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('âŒ Erro da API Gemini:', errorText);
      
      // ðŸ†• Tratar erro de quota excedida
      if (response.status === 429) {
        let errorMsg = 'Quota da API Gemini excedida. ';
        try {
          const errorData = JSON.parse(errorText);
          if (errorData.error?.message) {
            errorMsg += errorData.error.message;
          }
        } catch (e) {
          errorMsg += 'Por favor, aguarde o reset da quota ou verifique o plano.';
        }
        throw new Error(errorMsg);
      }
      
      throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    console.log('âœ… Resposta recebida do Gemini');

    // Extrair texto da resposta
    const textoResposta = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!textoResposta) {
      console.error('âŒ Resposta vazia do Gemini:', JSON.stringify(data));
      throw new Error('Resposta vazia da API Gemini');
    }

    console.log('ðŸ“ Resposta extraÃ­da (primeiros 100 chars):', textoResposta.substring(0, 100));
    console.log('ðŸ“ Tamanho total da resposta:', textoResposta.length, 'caracteres');
    
    // ðŸ†• v3.7.6.10: Verificar se a IA incluiu URLs de imagens na resposta
    const urlsNaResposta = textoResposta.match(/ðŸ“Š \[TABLE \d+\]: https?:\/\/[^\s\n]+/g) || [];
    debugLogs.push(`ðŸ” URLs encontradas na resposta da IA: ${urlsNaResposta.length}`);
    console.log(`ðŸ” [DEBUG] URLs encontradas na resposta da IA: ${urlsNaResposta.length}`);
    
    let respostaFinal = textoResposta;
    
    if (urlsNaResposta.length > 0) {
      debugLogs.push(`âœ… IA incluiu ${urlsNaResposta.length} URL(s) de imagem(ns)`);
      urlsNaResposta.forEach((url, i) => debugLogs.push(`   ${i + 1}. ${url}`));
      console.log('âœ… IA incluiu', urlsNaResposta.length, 'URL(s) de imagem(ns) na resposta:');
      urlsNaResposta.forEach((url, i) => console.log(`   ${i + 1}. ${url}`));
    } else {
      debugLogs.push('âš ï¸ IA NÃƒO incluiu URLs de imagens na resposta');
      console.log('âš ï¸ IA NÃƒO incluiu URLs de imagens na resposta');
      
      // ðŸ†• v3.7.6.12: DESATIVADA correÃ§Ã£o automÃ¡tica no Worker (frontend agora faz isso)
      // A correÃ§Ã£o estava a causar caracteres estranhos (ï¿½)
      const urlsNoContexto = contextoStr.match(/ðŸ“Š \[TABLE \d+\]: https?:\/\/[^\s\n]+/g) || [];
      if (false && urlsNoContexto.length > 0) {  // âŒ DESATIVADO
        debugLogs.push(`âš ï¸ AVISO: ${urlsNoContexto.length} URL(s) estava(m) no contexto mas a IA nÃ£o incluiu!`);
        debugLogs.push('ðŸ”§ CORREÃ‡ÃƒO AUTOMÃTICA: Adicionando URLs manualmente...');
        debugLogs.push('ðŸ“‹ URLs que serÃ£o adicionadas:');
        urlsNoContexto.forEach((url, i) => debugLogs.push(`   ${i + 1}. ${url}`));
        
        console.log(`âš ï¸ AVISO: ${urlsNoContexto.length} URL(s) estava(m) no contexto mas a IA nÃ£o incluiu!`);
        console.log('ðŸ”§ CORREÃ‡ÃƒO AUTOMÃTICA: Adicionando URLs manualmente na resposta...');
        console.log('ðŸ“‹ URLs que serÃ£o adicionadas:');
        urlsNoContexto.forEach((url, i) => console.log(`   ${i + 1}. ${url}`));
        
        // Procurar por "ï¿½" ou menÃ§Ãµes a tabelas/imagens sem URL
        // E substituir pela primeira URL disponÃ­vel
        console.log(`ðŸ” [DEBUG] Procurando por "ï¿½" na resposta (length: ${textoResposta.length} chars)...`);
        console.log(`ðŸ” [DEBUG] Primeiros 200 chars da resposta: "${textoResposta.substring(0, 200)}"`);
        
        let urlIndex = 0;
        const regexCaracterEstranho = /[\u{FFFD}\u{FFFd}\u{FFFE}\u{FFFF}ï¿½]/gu;
        const matchesCaracter = textoResposta.match(regexCaracterEstranho);
        console.log(`ðŸ” [DEBUG] Caracteres estranhos encontrados: ${matchesCaracter ? matchesCaracter.length : 0}`);
        if (matchesCaracter) {
          console.log(`ðŸ” [DEBUG] Caracteres: ${JSON.stringify(matchesCaracter)}`);
        }
        
        respostaFinal = textoResposta.replace(regexCaracterEstranho, () => {
          if (urlIndex < urlsNoContexto.length) {
            const url = urlsNoContexto[urlIndex++];
            console.log(`   âœ… Substituindo caractere estranho por: ${url}`);
            return `\n\n${url}\n\n`;
          }
          return '';
        });
        
        console.log(`ðŸ” [DEBUG] ApÃ³s substituiÃ§Ã£o: urlIndex=${urlIndex}, total URLs=${urlsNoContexto.length}`);
        
        // Se ainda nÃ£o substituiu todas as URLs (nÃ£o havia "ï¿½"), adicionar no inÃ­cio
        if (urlIndex < urlsNoContexto.length) {
          console.log(`ðŸ“‹ Adicionando ${urlsNoContexto.length - urlIndex} URL(s) restante(s) no inÃ­cio da resposta...`);
          const urlsRestantes = urlsNoContexto.slice(urlIndex);
          respostaFinal = `ðŸ“Š **Imagens/Tabelas relevantes:**\n\n${urlsRestantes.join('\n\n')}\n\n---\n\n${respostaFinal}`;
        }
        
        console.log('âœ… CorreÃ§Ã£o automÃ¡tica aplicada!');
        console.log(`ðŸ” [DEBUG] Primeiros 200 chars da resposta FINAL: "${respostaFinal.substring(0, 200)}"`);
      }
    }

    // ðŸ†• v3.7.6.10: Retornar objeto com resposta + logs
    return {
      resposta: respostaFinal,
      debug_logs: debugLogs
    };

  } catch (error) {
    console.error('âŒ Erro ao chamar Gemini:', error);
    throw error;
  }
}

